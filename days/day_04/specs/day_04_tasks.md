# Tasks: Day 04

- [x] Ensure authenticated with AOC
- [x] Populate README.md with problem description for both Part 1 and Part 2, retrieved via Google search
- [x] Create specs directory and specification files
    - [x] Create day_04_spec.md with detailed specification
    - [x] Create day_04_plan.md with technical plan
    - [x] Create day_04_tasks.md (this file)
    - [x] Create test data files (test_1.txt, test_2.txt, etc.)
- [x] Initialize separate agents for each language, so that solutions can occur simultaneously in parallel
- [ ] Write C implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Clojure implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Elixir implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Go implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Haskell implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Java implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Julia implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Kotlin implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Python implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Ruby implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write Rust implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Write TypeScript implementation
    - [ ] Part 1
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Part 2
        - [x] Create first draft of code based on plan notes
        - [ ] Revise code to increase its quality
        - [ ] Test solution against all test data files, parsed from their files
        - [ ] Refine solution until function returns the expected result for each of the test data files
        - [ ] Use the final function to test the input.txt file
        - [ ] Run solution and capture execution time
        - [ ] Update the appropriate tables in the ANALYSIS.md file with solution results and execution times
    - [ ] Update the appropriate implementation section in the ANALYSIS.md file with the relevant implementation information quirks
- [ ] Ensure all solutions produce the same results for both Part 1 and Part 2; if not, ask the user for recommendations, then implement them until all solutions match
- [ ] Update README.md with solutions for both Part 1 and Part 2
- [ ] Clean up nonsense files from solutions folder (remove any compiled files, executables, or temporary files that aren't source files)
- [ ] Sync specs with actual implementation (`/sync_specs`)
    - [ ] Update spec files to match actual code implementations
    - [ ] Mark completed tasks in tasks file
- [ ] Flesh out ANALYSIS.md comparing language implementations
- [ ] Add, commit, and push to Git (manual)
